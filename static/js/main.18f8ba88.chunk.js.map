{"version":3,"sources":["../node_modules/peerjs/dist sync","canvas.jsx","App.js","serviceWorker.js","index.js"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","getOriginFromDragging","_ref","offset","scaledPointer","x","y","Canvas","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","dom","React","createRef","onDrop","bind","assertThisInitialized","onPointerWheel","onResize","origin","scale","photos","canvas","current","loadPhotos","remotePointerImage","Image","src","addEventListener","onDragOver","window","touches","Touches","filtered","preventSimulated","on","onPointerStart","onPointerMove","onPointerEnd","addWheelListener","draw","disable","removeEventListener","removeWheelListener","socket","clientX","clientY","file","slicedToArray","dataTransfer","files","preventDefault","getPointer","reader","FileReader","onload","eReader","i","target","result","ie","c","document","createElement","width","height","getContext","drawImage","data","toDataURL","console","log","length","_id","Math","random","toString","substr","send","JSON","stringify","type","payload","photo","indexOf","_oldid","readAsDataURL","pointer","_this2","_this$props","button","_this$getPointer","intersects","filter","_ref2","image","reverse","dragging","shiftKey","peers","forEach","_ref3","connection","open","Int32Array","deltaY","_ref4","normalized","min","max","innerWidth","innerHeight","_ref6","_ref5","round","_this3","_ref7","_ref8","img","concat","_this4","_ref9","ctx","translate","_ref10","_ref11","_ref12","_pointer","restore","react_default","a","ref","Component","getPeerId","URLSearchParams","location","search","get","onData","setPeers","peerId","d","objectSpread","defineProperty","toConsumableArray","buildPeerConnection","p","peer","Room","_useState","useState","_useState2","setPhotos","_useState3","state","_useState4","appState","setAppState","_useState5","_useState6","reduce","sent","map","assign","useEffect","session","Peer","hash","replace","getHash","debug","URL","label","values","listenForPeer","makeFileConnection","connect","reliable","s","o","makeDataConnection","connectToHost","src_canvas","parse","App","className","App_Room","Boolean","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.18f8ba88.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 23;","import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport Touches from 'touches';\nimport { addWheelListener, removeWheelListener } from 'wheel';\n// import API from '@/services/api';\n\nconst getOriginFromDragging = ({offset, scaledPointer}) => (\n  { \n    x: offset.x + scaledPointer.x,\n    y: offset.y + scaledPointer.y\n  }\n)\n\nclass Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.dom = React.createRef();\n    this.onDrop = this.onDrop.bind(this);\n    this.onPointerWheel = this.onPointerWheel.bind(this);\n    this.onResize = this.onResize.bind(this);\n    // This is what controls the viewport translation\n    this.origin = { x: 0, y: 0 };\n    // This is what controls the viewport scaling\n    this.scale = 1;\n    // The photos are stored in the state as a base64 string\n    // We need to load the as Image objects in order to call ctx.drawImage\n    // (and also to extract their width & height for intersection testing)\n    // This is where we cache the loaded Image objects\n    this.photos = {};\n  }\n\n  componentDidMount() {\n    const { dom: { current: canvas } } = this;\n    // Load the inital set of photos\n    this.loadPhotos(this.props);\n    this.remotePointerImage = new Image()\n    this.remotePointerImage.src = 'https://togetherjs.com/togetherjs/images/cursor.svg'\n    // Bind the events\n    canvas.addEventListener('dragover', Canvas.onDragOver, false);\n    canvas.addEventListener('drop', this.onDrop, false);\n    window.addEventListener('resize', this.onResize, false);\n    this.touches = Touches(window, { filtered: true, preventSimulated: false })\n     .on('start', this.onPointerStart.bind(this))\n     .on('move', this.onPointerMove.bind(this))\n     .on('end', this.onPointerEnd.bind(this));\n    addWheelListener(window, this.onPointerWheel);\n    // Initial resize (this will also call the initial draw)\n    this.onResize();\n  }\n\n  componentWillReceiveProps(props) {\n    // The redux state has changed...\n    // Load photos as Image objects and store them in the cache\n    this.loadPhotos(props);\n    // Redraw\n    this.draw(props);\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  componentWillUnmount() {\n    const { dom: { current: canvas }, touches } = this;\n    // We're unloading the room\n    // Unbind all event handlers\n    touches.disable();\n    canvas.removeEventListener('dragover', Canvas.onDragOver);\n    canvas.removeEventListener('drop', this.onDrop);\n    removeWheelListener(window, this.onPointerWheel);\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  static onDragOver(e) {\n    e.preventDefault();\n  }\n\n  onDrop(e) {\n    // The user dropped a file into the canvas\n    const { socket } = this.props;\n    const {\n      clientX,\n      clientY,\n      dataTransfer: { files: [file] },\n    } = e;\n    e.preventDefault();\n    // We're only interested in files\n    if (!file) {\n      return;\n    }\n    // Get the screen-space pointer in room-space\n    const origin = this.getPointer([clientX, clientY]);\n    // Read the file\n    const reader = new FileReader();\n    reader.onload = (eReader) => {\n      // Once it loads, send it to the room server:\n      const i = new Image()\n      i.src = eReader.target.result\n      i.onload = function(ie) {\n        const c = document.createElement('canvas')\n        c.width = i.width\n        c.height = i.height\n        c.getContext('2d').drawImage(i, 0, 0)\n        const data = c.toDataURL('image/jpeg', 0.01)\n        console.log('small', data.length)\n        console.log('big', reader.result.length)\n        const _id = Math.random().toString(36).substr(2, 5)\n        socket.send(JSON.stringify({\n          type: 'ROOM/ADD_PHOTO',\n          payload: {\n            _id, \n            origin,\n            photo: data.substr(data.indexOf('base64') + 7),\n          },\n        }));\n        socket.send(JSON.stringify({\n          type: 'ROOM/ADD_PHOTO',\n          payload: {\n            _oldid: _id,\n            _id: Math.random().toString(36).substr(2, 5),\n            origin,\n            photo: reader.result.substr(reader.result.indexOf('base64') + 7),\n          },\n        }));\n      }\n    };\n    reader.readAsDataURL(file);\n  }\n\n  onPointerStart(e, pointer) {\n    const { photos, socket } = this.props;\n    const button = e.button || 0;\n    const { x, y } = this.getPointer(pointer);\n\n    // Get photo at pointer\n    const intersects = photos\n      .filter(({ _id, origin }) => {\n        const image = this.photos[_id];\n        // Filter it out if it hasn't been loaded\n        // yet into the cache as an Image object\n        if (!image) {\n          return false;\n        }\n        const { width, height } = image;\n        if (\n          x < origin.x\n          || x > origin.x + width\n          || y < origin.y\n          || y > origin.y + height\n        ) {\n          // The pointer is outside the bounds\n          return false;\n        }\n        // We got a hit!\n        return true;\n      });\n    // Reverse the filtered photos to get\n    // the one renderded on top first\n    intersects.reverse();\n    const photo = intersects[0];\n\n    if (\n      // Clicking the canvas (or right click)\n      // will drag it's origin\n      (button === 0 && !photo)\n      || (button === 2)\n    ) {\n      this.dragging = {\n        canvas: pointer,\n      };\n    } else if (\n      // Left click drags/removes photos\n      button === 0 && photo\n    ) {\n      if (e.shiftKey) {\n        // Shift+Click will remove the photo\n        socket.send(JSON.stringify({\n          type: 'ROOM/REMOVE_PHOTO',\n          payload: {\n            photo: photo._id,\n          },\n        }));\n      } else {\n        // Left click will drag the photo\n        this.dragging = {\n          offset: {\n            x: photo.origin.x - x,\n            y: photo.origin.y - y,\n          },\n          photo,\n        };\n      }\n    }\n  }\n\n  onPointerMove(e, pointer) {\n    const { dragging, origin, scale } = this;\n    const { peers } = this.props;\n    const scaledPointer = this.getPointer(pointer);\n    peers.forEach(({ data: connection }) => {\n      if ( connection && connection.open ) {\n        // console.log('sending...')\n        connection.send(new Int32Array([scaledPointer.x, scaledPointer.y]));\n      }\n    });\n    if (!dragging) {\n      return;\n    }\n    if (dragging.canvas) {\n      // Translate the canvas origin\n      origin.x += (pointer[0] - dragging.canvas[0]) / scale;\n      origin.y += (pointer[1] - dragging.canvas[1]) / scale;\n      dragging.canvas = pointer;\n    }\n    if (dragging.photo) {\n      dragging.scaledPointer = scaledPointer;\n    }\n    // Redraw\n    this.draw();\n  }\n\n  onPointerEnd() {\n    const { dragging } = this;\n    const { socket } = this.props;\n    if (!dragging) {\n      return;\n    }\n    delete this.dragging;\n    // we only have a scaledPointer if we have moved the image\n    if (dragging.photo && dragging.scaledPointer) {\n      // Send the final translation to the server\n      // So it gets saved into the db and broadcasted to the peers\n      const { _id: photo } = dragging.photo;\n      socket.send(JSON.stringify({\n        type: 'ROOM/MOVE_PHOTO',\n        payload: {\n          origin: getOriginFromDragging(dragging),\n          photo,\n        },\n      }));\n    }\n  }\n\n  onPointerWheel({ deltaY }) {\n    // Zoom the canvas in and out when the mouse wheel moves\n    const normalized = 1 + (Math.min(Math.max(-deltaY, -1), 1) * 0.075);\n    this.scale *= normalized;\n    this.scale = Math.min(Math.max(this.scale, 0.25), 2);\n    // Redraw\n    this.draw();\n  }\n\n  onResize() {\n    // Resize the canvas\n    const { dom: { current: canvas } } = this;\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    // Redraw\n    this.draw();\n  }\n\n  getPointer([x, y]) {\n    // Convert coordinates from screen-space to room-space\n    const { dom: { current: canvas }, origin, scale } = this;\n    return {\n      x: Math.round(((x - (canvas.width * 0.5)) / scale) - origin.x),\n      y: Math.round(((y - (canvas.height * 0.5)) / scale) - origin.y),\n    };\n  }\n\n  loadPhotos({ photos }) {\n    // Go through all the photos in the redux state\n    photos.forEach(({ _id, photo }) => {\n      // If it's not already in the cache, load it as an Image object\n      if (!this.photos[_id]) {\n        const img = new Image();\n        img.src = `data:image/jpeg;base64,${photo}`;\n        img.onload = () => {\n          // Redraw once it's loaded into the cache\n          this.photos[_id] = img;\n          this.draw()\n        }\n      }\n    });\n  }\n\n  draw(props) {\n    const { dom: { current: canvas }, origin, scale } = this;\n    const { peers, photos } = props || this.props;\n    const ctx = canvas.getContext('2d');\n    // Reset canvas context  TODO is this needed?\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n    // Room-space coordinates start at the middle of the canvas\n    ctx.translate(canvas.width * 0.5, canvas.height * 0.5);\n    // Apply user scale\n    ctx.scale(scale, scale);\n    // Apply user translation\n    ctx.translate(origin.x, origin.y);\n    // Go through all the photos in the redux state\n    photos.forEach(({ _id, origin }) => {\n      // Check the cache to see if the photo has been\n      // already loaded as an Image object by \"loadPhotos\"\n      if (this.photos[_id]) {\n        // Draw the cached Image object\n        const {dragging} = this\n        const {x, y} = (dragging && dragging.photo && dragging.photo._id === _id)\n          ? getOriginFromDragging(dragging)\n          : origin\n        // console.log('drawphoto', x, y)\n        ctx.drawImage(this.photos[_id], x, y);\n      }\n    });\n    // Go through all the peers in the redux state\n    peers.forEach(({ pointer }) => {\n      // Check  if we have received a pointer position\n      if (pointer) {\n        const [x, y] = pointer;\n        // Scale size with viewport\n        // TODO use scale\n        // Draw the cached Image object\n        ctx.drawImage(this.remotePointerImage, x, y);\n        ctx.restore();\n      }\n    });\n  }\n\n  render() {\n    const { dom } = this;\n    return (\n      <canvas ref={dom} />\n    );\n  }\n}\n\nCanvas.propTypes = {\n  peers: PropTypes.arrayOf(PropTypes.shape({\n    _id: PropTypes.string.isRequired,\n    connection: PropTypes.object.isRequired,\n    pointer: PropTypes.arrayOf(PropTypes.number),\n  })).isRequired,\n  photos: PropTypes.arrayOf(PropTypes.shape({\n    origin: PropTypes.shape({\n      x: PropTypes.number.isRequired,\n      y: PropTypes.number.isRequired,\n    }),\n    photo: PropTypes.string.isRequired,\n  })).isRequired,\n  socket: PropTypes.shape({ send: PropTypes.func.isRequired }).isRequired,\n};\n\nexport default Canvas\n","import React, { useState, useEffect } from 'react';\nimport Peer from 'peerjs';\nimport Canvas from './canvas';\nimport './App.css';\n\nconst getHash = () => {\n  const hash = window.location.hash\n  if (hash && typeof hash === 'string')\n    return hash.replace(/\\W/g, '')\n}\n\nconst getQuery = () => {\n  return new URLSearchParams(window.location.search).get('h')\n}\n\nconst getPeerId = getQuery\n\nconst onData = (data, setPeers, peerId) =>\n  data.on('data', (d) => {\n    // console.log('ddata', {d})\n    setPeers(peers => ({\n      ...peers,\n      [peerId]: {\n        ...peers[peerId],\n        pointer: [...(new Int32Array(d))]\n      }\n    }))\n  })\n\nconst buildPeerConnection = (type, connection) =>\n  p => ({...p, [connection.peer]: {...(p[connection.peer] || {}), [type]: connection}})\n\nconst listenForPeer = (session, setPeers, reduce, setPhotos) => {\n  session.on('connection', connection => {\n    if (connection.label === 'FILE') {\n      console.log('incomming file connection');\n      // setAppState(s => ({...s, state: 'transferring'}))\n      connection.on('open', (x) => {\n        console.log('incomming file connection open', connection)\n        // connection.send({file, name: file.name, size: file.size, type: file.type})\n        // FIXME doesnt actually setPeers, just send each one all the photos\n        setPhotos(photos => {\n          photos.forEach(photo =>\n            setPeers(peers => {\n              Object.values(peers).forEach(({ file: connection }) => {\n                if (connection.open) {\n                  connection.send({\n                    type: 'ROOM/ADD_PHOTO',\n                    payload: photo\n                  })\n                }\n              })\n              return peers\n            })\n          )\n          return photos\n        })\n        connection.on('data', (d) => {\n          console.log('fdata', {d})\n          reduce(d)\n        })\n      })\n\n      setPeers(buildPeerConnection('file', connection))\n    }\n\n    if (connection.label === 'DATA') {\n      console.log('incomming data connection');\n      connection.on('open', () => {\n        console.log('incomming data connection open', connection)\n        onData(connection, setPeers, connection.peer)\n      })\n      setPeers(buildPeerConnection('data', connection))\n    }\n  })\n}\n\nconst Room = () => { \n  const [photos, setPhotos] = useState([])\n  const [appState, setAppState] = useState({state: 'registering'})\n  // TODO let the connection manage its own peers\n  const [peers, setPeers] = useState({})\n  console.log('appState', appState.state)\n  console.log('peers', peers)\n\n  const reduce = sent => {\n    if (sent.type === 'ROOM/ADD_PHOTO') {\n      console.log('adding', sent.payload)\n      setPhotos(photos => [sent.payload, ...photos.filter(photo => photo._id !== sent.payload._oldid)])\n    }\n    if (sent.type === 'ROOM/REMOVE_PHOTO') {\n      console.log('removing', sent.payload)\n      setPhotos(photos => photos.filter(photo => photo._id !== sent.payload.photo))\n    }\n    if (sent.type === 'ROOM/MOVE_PHOTO') {\n      console.log('moving', sent.payload)\n      setPhotos(photos => photos.map(photo =>\n        photo._id === sent.payload.photo\n          ? Object.assign({}, photo, {origin: sent.payload.origin})\n          : photo\n      ))\n    }\n  }\n\n  useEffect(\n    () => {\n      const session = new Peer(getHash(), {debug: 3})\n      console.log({session})\n      session.on('open', id => {\n        console.log({id})\n        console.log(`${document.URL}?h=${id}`)\n        window.location.hash = id\n        const peerId = getPeerId()\n        setAppState({\n          state: peerId ? 'connectingToHost' : 'waitingForClientConnections',\n          id, session\n        })\n\n        if (!peerId)\n          listenForPeer(session, setPeers, reduce, setPhotos)\n\n        if (peerId) {\n          console.log('need to connect to ' + peerId)\n\n          const connectToHost = peerId => {\n            // make a file and data connection\n            const makeFileConnection = () => {\n              const file = session.connect(peerId, {label: 'FILE', reliable: true})\n              setPeers(buildPeerConnection('file', file))\n              setAppState(s => ({...s, state: 'waitingForOpen'}))\n\n              file.on('open', (o) => {\n                console.log('file connection open', o);\n                setAppState(s => ({\n                  ...s,\n                  state: s.state === 'waitingForOpen' ? 'waitingForOpen2' : 'open'\n                }))\n                file.on('data', (d) => {\n                  console.log('fdata', {d})\n                  reduce(d)\n                })\n              })\n\n              file.on('error', e => console.log('file error', e))\n              file.on('close', (x) => {\n                console.log('file reconnecting...', x)\n                makeFileConnection()\n              })\n            }\n\n            const makeDataConnection = () => {\n              const data = session.connect(peerId, {label: 'DATA'})\n              setPeers(buildPeerConnection('data', data))\n              data.on('open', (o) => {\n                console.log('data connection open', o);\n                setAppState(s => ({\n                  ...s,\n                  state: s.state === 'waitingForOpen' ? 'waitingForOpen2' : 'open'\n                }))\n                onData(data, setPeers, peerId)\n              })\n\n              data.on('error', e => console.log('data error', e))\n\n              data.on('close', (x) => {\n                console.log('data reconnecting...', x)\n                makeDataConnection()\n              })\n            }\n\n            makeFileConnection()\n            makeDataConnection()\n          }\n\n          connectToHost(peerId)\n        }\n      })\n    },\n    []\n  )\n\n  return (\n    <div>\n      <Canvas peers={Object.values(peers)} photos={photos} socket={{send: sent => {\n        sent = JSON.parse(sent)\n        console.log({sent})\n        reduce(sent)\n        Object.values(peers).forEach(({ file: connection }) => {\n          if (connection.open) \n            connection.send(sent)\n        })\n      }}} />\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Room />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}